{"ast":null,"code":"import * as THREE from \"three\";\nimport gsap from \"gsap\";\nlet cubeSize = 1;\n\nconst getIntersects = (originPoint, cubes, direction) => {\n  const intersectsResults = [];\n  const raycaster = new THREE.Raycaster();\n  const rayOrigin = new THREE.Vector3(originPoint.x, originPoint.y, 0);\n  let rayDirection;\n\n  switch (direction) {\n    case \"T\":\n      rayDirection = new THREE.Vector3(0, 2, 0).normalize();\n      break;\n\n    case \"R\":\n      rayDirection = new THREE.Vector3(2, 0, 0).normalize();\n      break;\n\n    case \"B\":\n      rayDirection = new THREE.Vector3(0, -2, 0).normalize();\n      break;\n\n    case \"L\":\n      rayDirection = new THREE.Vector3(-2, 0, 0).normalize();\n      break;\n\n    default:\n      break;\n  }\n\n  raycaster.set(rayOrigin, rayDirection);\n  const instersects = raycaster.intersectObjects(cubes).filter(mesh => mesh.object.userData.color !== undefined);\n\n  if (instersects.length > 0) {\n    let distantIntersect = false;\n\n    if (instersects[0].distance > 1) {\n      distantIntersect = true;\n    }\n\n    if (distantIntersect) {\n      intersectsResults.push(false);\n    } else {\n      intersectsResults.push(true);\n    }\n  } else {\n    intersectsResults.push(false);\n  }\n\n  return intersectsResults;\n};\n\nconst getDraggableIntersectionsOfSelectedSq = (originPoint, cubes) => {\n  const rayOrigin = new THREE.Vector3(originPoint.x, originPoint.y, 0);\n  const raycasterLeft = new THREE.Raycaster();\n  const raycasterTop = new THREE.Raycaster();\n  const raycasterRight = new THREE.Raycaster();\n  const raycasterBottom = new THREE.Raycaster();\n  const rayDirectionLeft = new THREE.Vector3(-2, 0, 0).normalize();\n  const rayDirectionTop = new THREE.Vector3(0, 2, 0).normalize();\n  const rayDirectionRight = new THREE.Vector3(2, 0, 0).normalize();\n  const rayDirectionBottom = new THREE.Vector3(0, -2, 0).normalize();\n  raycasterLeft.set(rayOrigin, rayDirectionLeft);\n  raycasterTop.set(rayOrigin, rayDirectionTop);\n  raycasterRight.set(rayOrigin, rayDirectionRight);\n  raycasterBottom.set(rayOrigin, rayDirectionBottom);\n  const instersectsLeft = raycasterLeft.intersectObjects(cubes).filter(mesh => mesh.object.userData.color !== undefined);\n  const instersectsTop = raycasterTop.intersectObjects(cubes).filter(mesh => mesh.object.userData.color !== undefined);\n  const instersectsRight = raycasterRight.intersectObjects(cubes).filter(mesh => mesh.object.userData.color !== undefined);\n  const instersectsBottom = raycasterBottom.intersectObjects(cubes).filter(mesh => mesh.object.userData.color !== undefined);\n  let intersectsResults = [];\n\n  if (instersectsTop.length > 0) {\n    const closeIntersections = instersectsTop.filter(intersect => intersect.distance <= 0.5);\n\n    if (closeIntersections.length > 0) {\n      intersectsResults.push({\n        T: originPoint.y\n      });\n    } else {\n      if (instersectsTop.length > 0) {\n        intersectsResults.push({\n          T: originPoint.y + instersectsTop[0].distance - cubeSize / 2\n        });\n      } else {//\n      }\n    }\n  }\n\n  if (instersectsRight.length > 0) {\n    const closeIntersections = instersectsRight.filter(intersect => intersect.distance <= 0.5);\n\n    if (closeIntersections.length > 0) {\n      intersectsResults.push({\n        R: originPoint.x\n      });\n    } else {\n      if (instersectsRight.length > 0) {\n        intersectsResults.push({\n          R: originPoint.x + instersectsRight[0].distance - cubeSize / 2\n        });\n      }\n    }\n  }\n\n  if (instersectsBottom.length > 0) {\n    const closeIntersections = instersectsBottom.filter(intersect => intersect.distance <= 0.5);\n\n    if (closeIntersections.length > 0) {\n      intersectsResults.push({\n        B: originPoint.y\n      });\n    } else {\n      if (instersectsBottom.length > 0) {\n        intersectsResults.push({\n          B: originPoint.y - instersectsBottom[0].distance + cubeSize / 2\n        });\n      }\n    }\n  }\n\n  if (instersectsLeft.length > 0) {\n    const closeIntersections = instersectsLeft.filter(intersect => intersect.distance <= 0.5);\n\n    if (closeIntersections.length > 0) {\n      intersectsResults.push({\n        L: originPoint.x\n      });\n    } else {\n      if (instersectsLeft.length > 0) {\n        intersectsResults.push({\n          L: originPoint.x - instersectsLeft[0].distance + cubeSize / 2\n        });\n      }\n    }\n  }\n\n  return intersectsResults;\n};\n\nconst getAvailableSqByDirection = (cubes, direction) => {\n  cubes.filter(cube => {\n    var originPoint = cube.position.clone();\n    const intersects = getIntersects(originPoint, cubes, direction);\n    var found = false;\n\n    for (var i = 0; i < intersects.length; i++) {\n      if (intersects[i]) {\n        found = intersects[i];\n        break;\n      } else {\n        const _duration = .1;\n        const _delay = 0;\n        const _easing = 'power2.out';\n\n        switch (direction) {\n          case \"T\":\n            // cube.position.y = cube.position.y + 1;\n            gsap.to(cube.position, {\n              duration: _duration,\n              delay: _delay,\n              y: cube.position.y + 1,\n              ease: _easing\n            });\n            break;\n\n          case \"R\":\n            gsap.to(cube.position, {\n              duration: _duration,\n              delay: _delay,\n              x: cube.position.x + 1,\n              ease: _easing\n            }); // cube.position.x = cube.position.x + 1;\n\n            break;\n\n          case \"B\":\n            // cube.position.y = cube.position.y - 1;\n            gsap.to(cube.position, {\n              duration: _duration,\n              delay: _delay,\n              y: cube.position.y - 1,\n              ease: _easing\n            });\n            break;\n\n          case \"L\":\n            // cube.position.x = cube.position.x - 1;\n            gsap.to(cube.position, {\n              duration: _duration,\n              delay: _delay,\n              x: cube.position.x - 1,\n              ease: _easing\n            });\n            break;\n\n          default:\n            break;\n        }\n      }\n    }\n\n    if (!found) {\n      return cube;\n    }\n  });\n};\n\nexport { getDraggableIntersectionsOfSelectedSq, getAvailableSqByDirection };","map":{"version":3,"sources":["/Users/drewstephenson/Documents/3DPortIntel/src/helper/intersects.js"],"names":["THREE","gsap","cubeSize","getIntersects","originPoint","cubes","direction","intersectsResults","raycaster","Raycaster","rayOrigin","Vector3","x","y","rayDirection","normalize","set","instersects","intersectObjects","filter","mesh","object","userData","color","undefined","length","distantIntersect","distance","push","getDraggableIntersectionsOfSelectedSq","raycasterLeft","raycasterTop","raycasterRight","raycasterBottom","rayDirectionLeft","rayDirectionTop","rayDirectionRight","rayDirectionBottom","instersectsLeft","instersectsTop","instersectsRight","instersectsBottom","closeIntersections","intersect","T","R","B","L","getAvailableSqByDirection","cube","position","clone","intersects","found","i","_duration","_delay","_easing","to","duration","delay","ease"],"mappings":"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","sourcesContent":["import * as THREE from \"three\";\nimport gsap from \"gsap\";\n\nlet cubeSize = 1;\n\nconst getIntersects = (originPoint, cubes, direction) => {\n  const intersectsResults = [];\n  const raycaster = new THREE.Raycaster();\n  const rayOrigin = new THREE.Vector3(originPoint.x, originPoint.y, 0);\n  let rayDirection;\n\n  switch (direction) {\n    case \"T\":\n      rayDirection = new THREE.Vector3(0, 2, 0).normalize();\n      break;\n\n    case \"R\":\n      rayDirection = new THREE.Vector3(2, 0, 0).normalize();\n      break;\n\n    case \"B\":\n      rayDirection = new THREE.Vector3(0, -2, 0).normalize();\n      break;\n\n    case \"L\":\n      rayDirection = new THREE.Vector3(-2, 0, 0).normalize();\n      break;\n\n    default:\n      break;\n  }\n\n  raycaster.set(rayOrigin, rayDirection);\n  const instersects = raycaster.intersectObjects(cubes)\n    .filter((mesh) => mesh.object.userData.color !== undefined);\n\n\n  if (instersects.length > 0) {\n    let distantIntersect = false;\n\n    if (instersects[0].distance > 1) {\n      distantIntersect = true\n    }\n    if (distantIntersect) {\n      intersectsResults.push(false);\n    } else {\n      intersectsResults.push(true);\n    }\n  } else {\n    intersectsResults.push(false);\n  }\n\n  return intersectsResults;\n}\n\nconst getDraggableIntersectionsOfSelectedSq = (originPoint, cubes) => {\n  const rayOrigin = new THREE.Vector3(originPoint.x, originPoint.y, 0);\n\n  const raycasterLeft = new THREE.Raycaster();\n  const raycasterTop = new THREE.Raycaster();\n  const raycasterRight = new THREE.Raycaster();\n  const raycasterBottom = new THREE.Raycaster();\n\n  const rayDirectionLeft = new THREE.Vector3(-2, 0, 0).normalize();\n  const rayDirectionTop = new THREE.Vector3(0, 2, 0).normalize();\n  const rayDirectionRight = new THREE.Vector3(2, 0, 0).normalize();\n  const rayDirectionBottom = new THREE.Vector3(0, -2, 0).normalize();\n\n  raycasterLeft.set(rayOrigin, rayDirectionLeft);\n  raycasterTop.set(rayOrigin, rayDirectionTop);\n  raycasterRight.set(rayOrigin, rayDirectionRight);\n  raycasterBottom.set(rayOrigin, rayDirectionBottom);\n\n  const instersectsLeft = raycasterLeft\n    .intersectObjects(cubes)\n    .filter((mesh) => mesh.object.userData.color !== undefined);\n  const instersectsTop = raycasterTop\n    .intersectObjects(cubes)\n    .filter((mesh) => mesh.object.userData.color !== undefined);\n  const instersectsRight = raycasterRight\n    .intersectObjects(cubes)\n    .filter((mesh) => mesh.object.userData.color !== undefined);\n  const instersectsBottom = raycasterBottom\n    .intersectObjects(cubes)\n    .filter((mesh) => mesh.object.userData.color !== undefined);\n\n  let intersectsResults = [];\n\n\n  if (instersectsTop.length > 0) {\n    const closeIntersections = instersectsTop.filter(\n      (intersect) => intersect.distance <= 0.5\n    );\n\n    if (closeIntersections.length > 0) {\n      intersectsResults.push({ T: originPoint.y });\n    } else {\n      if (instersectsTop.length > 0) {\n        intersectsResults.push({\n          T: originPoint.y + instersectsTop[0].distance - cubeSize / 2,\n        });\n      } else {\n        //\n      }\n    }\n  }\n\n  if (instersectsRight.length > 0) {\n    const closeIntersections = instersectsRight.filter(\n      (intersect) => intersect.distance <= 0.5\n    );\n    if (closeIntersections.length > 0) {\n      intersectsResults.push({ R: originPoint.x });\n    } else {\n      if (instersectsRight.length > 0) {\n        intersectsResults.push({\n          R: originPoint.x + instersectsRight[0].distance - cubeSize / 2,\n        });\n      }\n    }\n  }\n\n  if (instersectsBottom.length > 0) {\n    const closeIntersections = instersectsBottom.filter(\n      (intersect) => intersect.distance <= 0.5\n    );\n\n    if (closeIntersections.length > 0) {\n      intersectsResults.push({ B: originPoint.y });\n    } else {\n      if (instersectsBottom.length > 0) {\n        intersectsResults.push({\n          B: originPoint.y - instersectsBottom[0].distance + cubeSize / 2,\n        });\n      }\n    }\n  }\n\n  if (instersectsLeft.length > 0) {\n    const closeIntersections = instersectsLeft.filter(\n      (intersect) => intersect.distance <= 0.5\n    );\n\n    if (closeIntersections.length > 0) {\n      intersectsResults.push({ L: originPoint.x });\n    } else {\n      if (instersectsLeft.length > 0) {\n        intersectsResults.push({\n          L: originPoint.x - instersectsLeft[0].distance + cubeSize / 2,\n        });\n      }\n    }\n  }\n\n  return intersectsResults;\n}\n\nconst getAvailableSqByDirection = (cubes, direction) => {\n  cubes.filter(cube => {\n    var originPoint = cube.position.clone();\n    const intersects = getIntersects(originPoint, cubes, direction);\n    var found = false;\n    \n    for (var i = 0; i < intersects.length; i++) {\n      if (intersects[i]) {\n        found = intersects[i];\n        break;\n      } else {\n\n        const _duration = .1;\n        const _delay = 0;\n        const _easing = 'power2.out';\n\n        switch (direction) {\n          case \"T\":\n            // cube.position.y = cube.position.y + 1;\n            gsap.to(cube.position, { duration: _duration, delay: _delay, y: cube.position.y + 1, ease: _easing })\n            break;\n\n          case \"R\":\n            gsap.to(cube.position, { duration: _duration, delay: _delay, x: cube.position.x + 1, ease: _easing })\n            // cube.position.x = cube.position.x + 1;\n            break;\n\n          case \"B\":\n            // cube.position.y = cube.position.y - 1;\n            gsap.to(cube.position, { duration: _duration, delay: _delay, y: cube.position.y - 1, ease: _easing })\n            break;\n\n          case \"L\":\n            // cube.position.x = cube.position.x - 1;\n            gsap.to(cube.position, { duration: _duration, delay: _delay, x: cube.position.x - 1, ease: _easing })\n            break;\n\n          default:\n            break;\n        }\n\n      }\n    }\n\n    if (!found) {\n      return cube;\n    }\n  });\n}\n\nexport { getDraggableIntersectionsOfSelectedSq, getAvailableSqByDirection };"]},"metadata":{},"sourceType":"module"}