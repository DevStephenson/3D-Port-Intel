{"ast":null,"code":"var _jsxFileName = \"/Users/drewstephenson/Documents/3DPortIntel/src/Globe.js\";\nimport React, { Component } from \"react\"; // import './styles/App.scss';\n\nimport * as THREE from \"three\";\nimport * as _ from 'lodash'; // import Moment from 'react-moment';\n\nimport moment from 'moment'; // import gsap from \"gsap\";\n\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\nimport { DragControls } from \"three/examples/jsm/controls/DragControls\";\nimport { shuffle, isWinningCombination } from \"./helper/helper\";\nimport { rubik_colors, color_opt_array } from \"./cubes/colors\";\nimport { getDraggableIntersectionsOfSelectedSq, getAvailableSqByDirection } from './helper/intersects'; // import { generateGameboardCubes, generateMasterCubes } from './cubes/gameboard';\n// import { generateMasterCubeDisplay } from './controls/controls';\n\nimport { BsChevronDown, BsChevronLeft, BsChevronRight, BsChevronUp } from 'react-icons/bs';\nimport { FiMenu } from 'react-icons/fi'; // debuger\n// const gui = new dat.GUI({ closed: true });\n// global\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nlet camera, dragControls, scene, renderer, appEl;\nlet controls;\nlet cubes = [];\nlet masterCubes = [];\nlet masterCubesHTML;\nlet gamePieces;\nlet setInervalTimer;\nlet masterGameMap = new Map();\nconst boardGameMap = new Map();\nconst game_map_row1 = new Map();\nconst game_map_row2 = new Map();\nconst game_map_row3 = new Map();\nconst boardGameMap_row1 = new Map();\nconst boardGameMap_row2 = new Map();\nconst boardGameMap_row3 = new Map();\nmasterGameMap.set(0, game_map_row1);\nmasterGameMap.set(1, game_map_row2);\nmasterGameMap.set(2, game_map_row3);\nboardGameMap.set(0, boardGameMap_row1);\nboardGameMap.set(1, boardGameMap_row2);\nboardGameMap.set(2, boardGameMap_row3);\nconst gridCount = 5;\nlet cubeSize = 1;\nconst masterCubeSize = cubeSize / 2;\nconst masterGridCount = 3;\n\nclass Globe extends Component {\n  constructor() {\n    super();\n\n    this.bindKeyPress = () => {\n      window.addEventListener(\"keydown\", e => {\n        e.preventDefault();\n        let isAnimating = false;\n\n        if (!this.debouncedFn) {\n          this.debouncedFn = _.debounce(key => {\n            switch (key) {\n              case 'ArrowLeft':\n                // left\n                getAvailableSqByDirection(cubes, \"L\");\n                this.checkCombinationMatches();\n                isAnimating = false;\n                break;\n\n              case 'ArrowUp':\n                // up\n                getAvailableSqByDirection(cubes, \"T\");\n                this.checkCombinationMatches();\n                isAnimating = false;\n                break;\n\n              case 'ArrowRight':\n                // right\n                getAvailableSqByDirection(cubes, \"R\");\n                this.checkCombinationMatches();\n                isAnimating = false;\n                break;\n\n              case 'ArrowDown':\n                // down\n                getAvailableSqByDirection(cubes, \"B\");\n                this.checkCombinationMatches();\n                isAnimating = false;\n                break;\n\n              default:\n                return;\n              // exit this handler\n            }\n          }, 100);\n        }\n\n        if (!isAnimating) {\n          isAnimating = true;\n          this.debouncedFn(e.key);\n        }\n      });\n    };\n\n    this.bindResize = () => {\n      window.addEventListener(\"resize\", e => {\n        camera.aspect = window.innerWidth / window.innerHeight;\n        camera.updateProjectionMatrix();\n        renderer.setSize(window.innerWidth, window.innerHeight);\n      });\n    };\n\n    this.generateMasterCubes = () => {\n      let count = 0;\n      let i, j;\n      const randomColors = shuffle(color_opt_array);\n\n      for (i = 0; i < masterGridCount; i++) {\n        for (j = 0; j < masterGridCount; j++) {\n          masterCubes.push(randomColors[count]);\n          masterGameMap.get(i).set(j, randomColors[count]);\n          count++;\n        }\n      } // update for faster comparison\n\n\n      masterGameMap = this.syncMasterCubeOrder(masterGameMap); //     const cubeArr = generateMasterCubeDisplay(masterGameMap);\n      //     this.setState({ masterCubeArr: cubeArr });\n    };\n\n    this.syncMasterCubeOrder = masterCubes => {\n      const outObj = masterCubes;\n      outObj.forEach(map => {\n        const value0 = map.get(0);\n        const value2 = map.get(2);\n        map.set(0, value2);\n        map.set(2, value0);\n      });\n      return outObj;\n    };\n\n    this.generateGridHelper = () => {\n      var standardPlaneNormal = new THREE.Vector3(0, 0, 1);\n      var GridHelperPlaneNormal = new THREE.Vector3(0, 1, 0);\n      var GridHelperPlaneMaster = new THREE.Vector3(0, 1, 0);\n      var quaternion = new THREE.Quaternion();\n      quaternion.setFromUnitVectors(standardPlaneNormal, GridHelperPlaneNormal);\n      var masterQuaternion = new THREE.Quaternion();\n      masterQuaternion.setFromUnitVectors(standardPlaneNormal, GridHelperPlaneMaster);\n      var largeGridGuide = new THREE.GridHelper(10, 10);\n      largeGridGuide.rotation.setFromQuaternion(quaternion);\n      scene.add(largeGridGuide);\n    };\n\n    this.animation = _time => {\n      cubes.forEach(o => {\n        o.userData.update(o);\n      });\n      controls.update();\n      renderer.render(scene, camera);\n    };\n\n    this.checkCombinationMatches = () => {\n      gamePieces.children.filter(p => {\n        const piecePos = p.position.clone();\n        const x = Math.round(piecePos.x);\n        const y = Math.round(piecePos.y);\n        const whitelist = [0, 1, -1];\n\n        if (whitelist.includes(x) && whitelist.includes(y)) {\n          const currentBoardRow = boardGameMap.get(x + 1);\n          currentBoardRow.set(y + 1, p.userData.color);\n        }\n      });\n\n      if (isWinningCombination(boardGameMap, masterGameMap)) {\n        console.log(\" You Win!\");\n      }\n    };\n\n    this.generateCubes = () => {\n      gamePieces = new THREE.Group();\n      const doubleCubeSize = cubeSize * 2;\n      let count = 0;\n      let i, j;\n      const randomColors = shuffle(color_opt_array);\n\n      for (i = 0; i < gridCount; i++) {\n        for (j = 0; j < gridCount; j++) {\n          let material = new THREE.MeshBasicMaterial({\n            color: rubik_colors[randomColors[count]]\n          });\n          let cube_geometry;\n          let xPos = -1 * i + cubeSize * 2;\n          let yPos = -1 * j + cubeSize * 2;\n          cube_geometry = new THREE.BoxGeometry(cubeSize, cubeSize, 0.1); // let isX = xPos === 1 || xPos === 0 || xPos === -1;\n          // let isY = yPos === 1 || yPos === 0 || yPos === -1;\n          // if(isX && isY){\n          //   cube_geometry = new THREE.BoxGeometry(\n          //     cubeSize,\n          //     cubeSize,\n          //     0.5\n          //   );\n          // } else {\n          //   cube_geometry = new THREE.BoxGeometry(\n          //     cubeSize,\n          //     cubeSize,\n          //     0.1\n          //   );\n          // }\n\n          const cube = new THREE.Mesh(cube_geometry, material);\n          cube.position.x = xPos;\n          cube.position.y = yPos;\n          cube.userData.id = `${i}${j}`;\n          cube.userData.color = randomColors[count];\n          cube.userData.intersects = [];\n          cube.userData.position = cube.position.clone(); // prototype\n\n          cube.userData.update = $this => {\n            let cube_limit = {};\n\n            if ($this.userData.intersects.length > 0) {\n              let dataIntersects = $this.userData.intersects;\n              const TopLimit = dataIntersects.find(obj => Object.keys(obj).includes(\"T\"));\n              const RightLimit = dataIntersects.find(obj => Object.keys(obj).includes(\"R\"));\n              const BottomLimit = dataIntersects.find(obj => Object.keys(obj).includes(\"B\"));\n              const LeftLimit = dataIntersects.find(obj => Object.keys(obj).includes(\"L\"));\n              const xMin = LeftLimit ? LeftLimit.L : -1 * doubleCubeSize;\n              const yMin = BottomLimit ? BottomLimit.B : -1 * doubleCubeSize;\n              const xMax = RightLimit ? RightLimit.R : doubleCubeSize;\n              const yMax = TopLimit ? TopLimit.T : doubleCubeSize;\n              cube_limit.max = new THREE.Vector3(xMax, yMax, 0);\n              cube_limit.min = new THREE.Vector3(xMin, yMin, 0);\n            } else {\n              cube_limit.min = new THREE.Vector3(-1 * doubleCubeSize, -1 * doubleCubeSize, 0);\n              cube_limit.max = new THREE.Vector3(doubleCubeSize, doubleCubeSize, 0);\n            } //\n\n\n            cube.position.clamp(cube_limit.min, cube_limit.max);\n          };\n\n          cube.userData.setColor = color => {\n            cube.material.color.setHex(color);\n          };\n\n          cube.userData.checkCombinationMatches = () => {\n            this.checkCombinationMatches();\n          };\n\n          cubes.push(cube);\n\n          if (i !== 4 || j !== 4) {\n            gamePieces.add(cube);\n          }\n\n          count++;\n        }\n      }\n\n      scene.add(gamePieces);\n      /*\n         DRAG CONTROLS\n       */\n\n      dragControls = new DragControls(cubes, camera, renderer.domElement);\n      dragControls.addEventListener(\"dragstart\", function (event) {\n        // affect obj\n        // event.object.userData.setColor('0xff0000');\n        let cube = event.object;\n        var originPoint = cube.position.clone(); //       cube.userData.intersects = getDraggableIntersectionsOfSelectedSq(originPoint, cubes);\n\n        cube.userData.update(cube);\n        controls.enabled = false;\n      });\n      dragControls.addEventListener(\"drag\", function (event) {\n        let cube = event.object;\n        cube.position.z = 0; // This will prevent moving z axis, but will be on 0 line. change this to your object position of z axis.\n      });\n      dragControls.addEventListener(\"dragend\", function (event) {\n        controls.enabled = true;\n        renderer.render(scene, camera);\n      });\n      /*\n       END DRAG CONTROLS\n       */\n    };\n\n    this.startClock = () => {\n      const startTime = parseInt(this.state.startTime, 10);\n      setInervalTimer = setInterval(() => {\n        let startTime = parseInt(this.state.clock);\n        this.setState({\n          clock: startTime + 1\n        });\n      }, 1000); // update about every second\n\n      return setInervalTimer;\n    };\n\n    this.formatDoubleDigit = time => {\n      if (time < 10) {\n        return `0${time}`;\n      } else {\n        return time;\n      }\n\n      ;\n    };\n\n    this.parseClock = time => {\n      return time < 60 ? `00 : ${this.formatDoubleDigit(time)}` : `${this.formatDoubleDigit(Math.floor(time / 60))} : ${this.formatDoubleDigit(time % 60)}`;\n    };\n\n    this.init = () => {\n      camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.01, 100);\n      camera.position.z = 6;\n      scene = new THREE.Scene();\n      renderer = new THREE.WebGLRenderer({\n        antialias: true,\n        alpha: true\n      }); // renderer.setClearColor( 0x000000, 0 ); // the default\n\n      renderer.setSize(window.innerWidth, window.innerHeight);\n      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1));\n      renderer.setAnimationLoop(this.animation);\n      controls = new OrbitControls(camera, appEl);\n      controls.enableDamping = true; // setup Map\n\n      const globeGeo = new THREE.SphereBufferGeometry(1);\n      const globe = new THREE.Mesh(globeGeo, material);\n      gamePieces = new THREE.Group();\n      gamePieces.add(globe);\n      scene.add(gamePieces); //     this.generateCubes();\n      // generateGameboardCubes(scene, camera, renderer, controls);\n      //     this.generateMasterCubes(scene);\n      // this.generateGridHelper();\n\n      this.startClock();\n      appEl.appendChild(renderer.domElement);\n    };\n\n    this.directionalButtonPress = e => {\n      let isAnimating = false;\n      const direction = e.target.getAttribute(\"data-direction\");\n\n      if (!this.debouncedFn) {\n        this.debouncedFn = _.debounce(direction => {\n          switch (direction) {\n            case 'ArrowLeft':\n              // left\n              getAvailableSqByDirection(cubes, \"L\");\n              this.checkCombinationMatches();\n              isAnimating = false;\n              break;\n\n            case 'ArrowUp':\n              // up\n              getAvailableSqByDirection(cubes, \"T\");\n              this.checkCombinationMatches();\n              isAnimating = false;\n              break;\n\n            case 'ArrowRight':\n              // right\n              getAvailableSqByDirection(cubes, \"R\");\n              this.checkCombinationMatches();\n              isAnimating = false;\n              break;\n\n            case 'ArrowDown':\n              // down\n              getAvailableSqByDirection(cubes, \"B\");\n              this.checkCombinationMatches();\n              isAnimating = false;\n              break;\n\n            default:\n              return;\n            // exit this handler\n          }\n        }, 100);\n      }\n\n      if (!isAnimating && direction) {\n        isAnimating = true;\n        this.debouncedFn(direction);\n      }\n    };\n\n    this.state = {\n      startTime: 0,\n      clock: 0,\n      masterCubeArr: []\n    };\n  }\n\n  componentDidMount() {\n    appEl = document.getElementsByClassName(\"webgl\")[0];\n    this.init();\n    this.bindResize();\n    this.bindKeyPress();\n  }\n\n  render() {\n    return /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"header\",\n        children: [/*#__PURE__*/_jsxDEV(\"span\", {\n          className: \"title\",\n          children: \"Rubix\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 445,\n          columnNumber: 9\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"timer\",\n          children: this.parseClock(this.state.clock)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 447,\n          columnNumber: 9\n        }, this), /*#__PURE__*/_jsxDEV(FiMenu, {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 451,\n          columnNumber: 7\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 444,\n        columnNumber: 7\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"webgl\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 454,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true);\n  }\n\n}\n\nexport default Globe;","map":{"version":3,"sources":["/Users/drewstephenson/Documents/3DPortIntel/src/Globe.js"],"names":["React","Component","THREE","_","moment","OrbitControls","DragControls","shuffle","isWinningCombination","rubik_colors","color_opt_array","getDraggableIntersectionsOfSelectedSq","getAvailableSqByDirection","BsChevronDown","BsChevronLeft","BsChevronRight","BsChevronUp","FiMenu","camera","dragControls","scene","renderer","appEl","controls","cubes","masterCubes","masterCubesHTML","gamePieces","setInervalTimer","masterGameMap","Map","boardGameMap","game_map_row1","game_map_row2","game_map_row3","boardGameMap_row1","boardGameMap_row2","boardGameMap_row3","set","gridCount","cubeSize","masterCubeSize","masterGridCount","Globe","constructor","bindKeyPress","window","addEventListener","e","preventDefault","isAnimating","debouncedFn","debounce","key","checkCombinationMatches","bindResize","aspect","innerWidth","innerHeight","updateProjectionMatrix","setSize","generateMasterCubes","count","i","j","randomColors","push","get","syncMasterCubeOrder","outObj","forEach","map","value0","value2","generateGridHelper","standardPlaneNormal","Vector3","GridHelperPlaneNormal","GridHelperPlaneMaster","quaternion","Quaternion","setFromUnitVectors","masterQuaternion","largeGridGuide","GridHelper","rotation","setFromQuaternion","add","animation","_time","o","userData","update","render","children","filter","p","piecePos","position","clone","x","Math","round","y","whitelist","includes","currentBoardRow","color","console","log","generateCubes","Group","doubleCubeSize","material","MeshBasicMaterial","cube_geometry","xPos","yPos","BoxGeometry","cube","Mesh","id","intersects","$this","cube_limit","length","dataIntersects","TopLimit","find","obj","Object","keys","RightLimit","BottomLimit","LeftLimit","xMin","L","yMin","B","xMax","R","yMax","T","max","min","clamp","setColor","setHex","domElement","event","object","originPoint","enabled","z","startClock","startTime","parseInt","state","setInterval","clock","setState","formatDoubleDigit","time","parseClock","floor","init","PerspectiveCamera","Scene","WebGLRenderer","antialias","alpha","setPixelRatio","devicePixelRatio","setAnimationLoop","enableDamping","globeGeo","SphereBufferGeometry","globe","appendChild","directionalButtonPress","direction","target","getAttribute","masterCubeArr","componentDidMount","document","getElementsByClassName"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\";\n// import './styles/App.scss';\nimport * as THREE from \"three\";\nimport * as _ from 'lodash';\n// import Moment from 'react-moment';\nimport moment from 'moment';\n\n// import gsap from \"gsap\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\nimport { DragControls } from \"three/examples/jsm/controls/DragControls\";\nimport { shuffle, isWinningCombination } from \"./helper/helper\";\nimport { rubik_colors, color_opt_array } from \"./cubes/colors\";\nimport { getDraggableIntersectionsOfSelectedSq, getAvailableSqByDirection } from './helper/intersects';\n// import { generateGameboardCubes, generateMasterCubes } from './cubes/gameboard';\n// import { generateMasterCubeDisplay } from './controls/controls';\nimport { BsChevronDown, BsChevronLeft, BsChevronRight, BsChevronUp } from 'react-icons/bs';\nimport { FiMenu } from 'react-icons/fi';\n\n// debuger\n// const gui = new dat.GUI({ closed: true });\n\n// global\nlet camera, dragControls, scene, renderer, appEl;\nlet controls;\nlet cubes = [];\nlet masterCubes = [];\nlet masterCubesHTML;\nlet gamePieces;\nlet setInervalTimer;\n\nlet masterGameMap = new Map();\nconst boardGameMap = new Map();\n\nconst game_map_row1 = new Map();\nconst game_map_row2 = new Map();\nconst game_map_row3 = new Map();\n\nconst boardGameMap_row1 = new Map();\nconst boardGameMap_row2 = new Map();\nconst boardGameMap_row3 = new Map();\n\nmasterGameMap.set(0, game_map_row1);\nmasterGameMap.set(1, game_map_row2);\nmasterGameMap.set(2, game_map_row3);\n\nboardGameMap.set(0, boardGameMap_row1);\nboardGameMap.set(1, boardGameMap_row2);\nboardGameMap.set(2, boardGameMap_row3);\n\nconst gridCount = 5;\nlet cubeSize = 1;\nconst masterCubeSize = cubeSize / 2;\nconst masterGridCount = 3;\n\nclass Globe extends Component {\n  constructor() {\n    super();\n    this.state = {\n      startTime:0,\n      clock:0,\n      masterCubeArr: []\n    };\n  }\n\n  componentDidMount() {\n    appEl = document.getElementsByClassName(\"webgl\")[0];\n    this.init();\n    this.bindResize();\n    this.bindKeyPress();\n  }\n\n  bindKeyPress = () => {\n    window.addEventListener(\"keydown\", (e) => {\n      e.preventDefault();\n\n      let isAnimating = false;\n\n      if (!this.debouncedFn) {\n        this.debouncedFn = _.debounce((key) => {\n          switch (key) {\n            case 'ArrowLeft': // left\n              getAvailableSqByDirection(cubes, \"L\");\n              this.checkCombinationMatches();\n              isAnimating = false;\n              break;\n\n            case 'ArrowUp': // up\n              getAvailableSqByDirection(cubes, \"T\");\n              this.checkCombinationMatches();\n              isAnimating = false;\n              break;\n\n            case 'ArrowRight': // right\n              getAvailableSqByDirection(cubes, \"R\");\n              this.checkCombinationMatches();\n              isAnimating = false;\n              break;\n\n            case 'ArrowDown': // down\n              getAvailableSqByDirection(cubes, \"B\");\n              this.checkCombinationMatches();\n              isAnimating = false;\n              break;\n\n            default: return; // exit this handler\n          }\n        }, 100);\n      }\n\n      if (!isAnimating) {\n        isAnimating = true;\n        this.debouncedFn(e.key);\n      }\n\n    });\n  }\n\n  bindResize = () => {\n    window.addEventListener(\"resize\", (e) => {\n      camera.aspect = window.innerWidth / window.innerHeight;\n      camera.updateProjectionMatrix();\n      renderer.setSize(window.innerWidth, window.innerHeight);\n    });\n  };\n\n  generateMasterCubes = () => {\n    let count = 0;\n    let i, j;\n\n    const randomColors = shuffle(color_opt_array);\n\n    for (i = 0; i < masterGridCount; i++) {\n      for (j = 0; j < masterGridCount; j++) {\n        masterCubes.push(randomColors[count]);\n        masterGameMap.get(i).set(j, randomColors[count])\n        count++;\n      }\n    }\n\n    // update for faster comparison\n    masterGameMap = this.syncMasterCubeOrder(masterGameMap);\n//     const cubeArr = generateMasterCubeDisplay(masterGameMap);\n//     this.setState({ masterCubeArr: cubeArr });\n  };\n\n  syncMasterCubeOrder = (masterCubes) => {\n    const outObj = masterCubes;\n\n    outObj.forEach(map => {\n      const value0 = map.get(0);\n      const value2 = map.get(2);\n\n      map.set(0, value2);\n      map.set(2, value0);\n    })\n\n    return outObj;\n  }\n\n  generateGridHelper = () => {\n    var standardPlaneNormal = new THREE.Vector3(0, 0, 1);\n    var GridHelperPlaneNormal = new THREE.Vector3(0, 1, 0);\n    var GridHelperPlaneMaster = new THREE.Vector3(0, 1, 0);\n\n    var quaternion = new THREE.Quaternion();\n    quaternion.setFromUnitVectors(standardPlaneNormal, GridHelperPlaneNormal);\n\n    var masterQuaternion = new THREE.Quaternion();\n    masterQuaternion.setFromUnitVectors(standardPlaneNormal, GridHelperPlaneMaster);\n\n    var largeGridGuide = new THREE.GridHelper(10, 10);\n    largeGridGuide.rotation.setFromQuaternion(quaternion);\n\n    scene.add(largeGridGuide);\n  }\n\n  animation = (_time) => {\n    cubes.forEach((o) => {\n      o.userData.update(o);\n    });\n\n    controls.update();\n    renderer.render(scene, camera);\n  };\n\n  checkCombinationMatches = () => {\n    gamePieces.children.filter((p) => {\n      const piecePos = p.position.clone();\n      const x = Math.round(piecePos.x);\n      const y = Math.round(piecePos.y);\n      const whitelist = [0, 1, -1];\n\n      if (whitelist.includes(x) && whitelist.includes(y)) {\n        const currentBoardRow = boardGameMap.get(x + 1);\n        currentBoardRow.set(y + 1, p.userData.color);\n      }\n    })\n\n    if (isWinningCombination(boardGameMap, masterGameMap)) {\n      console.log(\" You Win!\");\n    }\n  }\n\n  generateCubes = () => {\n    gamePieces = new THREE.Group();\n    \n\n    const doubleCubeSize = cubeSize * 2;\n    let count = 0;\n    let i, j;\n\n    const randomColors = shuffle(color_opt_array);\n\n    for (i = 0; i < gridCount; i++) {\n      for (j = 0; j < gridCount; j++) {\n\n        let material = new THREE.MeshBasicMaterial({\n          color: rubik_colors[randomColors[count]],\n        });\n\n        let cube_geometry;\n        let xPos = -1 * i + cubeSize * 2;\n        let yPos = -1 * j + cubeSize * 2;\n\n        cube_geometry = new THREE.BoxGeometry(\n            cubeSize,\n            cubeSize,\n            0.1\n          );\n\n        // let isX = xPos === 1 || xPos === 0 || xPos === -1;\n        // let isY = yPos === 1 || yPos === 0 || yPos === -1;\n\n        // if(isX && isY){\n        //   cube_geometry = new THREE.BoxGeometry(\n        //     cubeSize,\n        //     cubeSize,\n        //     0.5\n        //   );\n        // } else {\n        //   cube_geometry = new THREE.BoxGeometry(\n        //     cubeSize,\n        //     cubeSize,\n        //     0.1\n        //   );\n        // }\n        \n\n        const cube = new THREE.Mesh(cube_geometry, material);\n        cube.position.x = xPos;\n        cube.position.y = yPos;\n        cube.userData.id = `${i}${j}`;\n        cube.userData.color = randomColors[count];\n        cube.userData.intersects = [];\n        cube.userData.position = cube.position.clone();\n\n        // prototype\n        cube.userData.update = ($this) => {\n          let cube_limit = {};\n\n          if ($this.userData.intersects.length > 0) {\n            let dataIntersects = $this.userData.intersects;\n\n            const TopLimit = dataIntersects.find((obj) => Object.keys(obj).includes(\"T\"));\n            const RightLimit = dataIntersects.find((obj) => Object.keys(obj).includes(\"R\"));\n            const BottomLimit = dataIntersects.find((obj) => Object.keys(obj).includes(\"B\"));\n            const LeftLimit = dataIntersects.find((obj) => Object.keys(obj).includes(\"L\"));\n\n            const xMin = LeftLimit ? LeftLimit.L : -1 * doubleCubeSize;\n            const yMin = BottomLimit ? BottomLimit.B : -1 * doubleCubeSize;\n            const xMax = RightLimit ? RightLimit.R : doubleCubeSize;\n            const yMax = TopLimit ? TopLimit.T : doubleCubeSize;\n\n            cube_limit.max = new THREE.Vector3(xMax, yMax, 0);\n            cube_limit.min = new THREE.Vector3(xMin, yMin, 0);\n          } else {\n            cube_limit.min = new THREE.Vector3(-1 * doubleCubeSize, -1 * doubleCubeSize, 0);\n            cube_limit.max = new THREE.Vector3(doubleCubeSize, doubleCubeSize, 0);\n          }\n\n          //\n          cube.position.clamp(cube_limit.min, cube_limit.max);\n        };\n\n        cube.userData.setColor = (color) => {\n          cube.material.color.setHex(color);\n        };\n\n        cube.userData.checkCombinationMatches = () => {\n          this.checkCombinationMatches();\n        }\n\n        cubes.push(cube);\n\n        if (i !== 4 || j !== 4) {\n          gamePieces.add(cube);\n        }\n\n        count++;\n      }\n    }\n\n    scene.add(gamePieces);\n\n    /*\n       DRAG CONTROLS\n     */\n\n    dragControls = new DragControls(cubes, camera, renderer.domElement);\n\n    dragControls.addEventListener(\"dragstart\", function (event) {\n      // affect obj\n      // event.object.userData.setColor('0xff0000');\n\n      let cube = event.object;\n      var originPoint = cube.position.clone();\n\n//       cube.userData.intersects = getDraggableIntersectionsOfSelectedSq(originPoint, cubes);\n      cube.userData.update(cube);\n      controls.enabled = false;\n    });\n\n    dragControls.addEventListener(\"drag\", function (event) {\n      let cube = event.object;\n      cube.position.z = 0; // This will prevent moving z axis, but will be on 0 line. change this to your object position of z axis.\n    });\n\n    dragControls.addEventListener(\"dragend\", function (event) {\n      controls.enabled = true;\n      renderer.render(scene, camera);\n\n    });\n\n    /*\n     END DRAG CONTROLS\n     */\n  };\n\n  startClock = () => {\n    const startTime = parseInt(this.state.startTime, 10);\n    setInervalTimer = setInterval(()  => {\n      let startTime = parseInt(this.state.clock);\n      this.setState({ clock: startTime + 1 });\n    }, 1000); // update about every second\n    return setInervalTimer;\n  }\n\n  formatDoubleDigit = (time) => {\n    if(time < 10){\n      return `0${time}`\n    } else { \n      return time;\n    };\n  }\n  parseClock = (time) => {\n    return time < 60 ?`00 : ${this.formatDoubleDigit(time)}` : `${this.formatDoubleDigit(Math.floor(time/60))} : ${this.formatDoubleDigit(time%60)}`;\n  }\n\n  init = () => {\n    camera = new THREE.PerspectiveCamera(\n      90,\n      window.innerWidth / window.innerHeight,\n      0.01,\n      100\n    );\n    camera.position.z = 6;\n    scene = new THREE.Scene();\n\n    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\n    // renderer.setClearColor( 0x000000, 0 ); // the default\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1));\n    renderer.setAnimationLoop(this.animation);\n\n    controls = new OrbitControls(camera, appEl);\n    controls.enableDamping = true;\n\n    // setup Map\n\n    const globeGeo = new THREE.SphereBufferGeometry(1);\n    const globe = new THREE.Mesh(globeGeo, material)\n\n\n    gamePieces = new THREE.Group();\n    gamePieces.add(globe);\n    scene.add(gamePieces);\n    //     this.generateCubes();\n\n    // generateGameboardCubes(scene, camera, renderer, controls);\n    //     this.generateMasterCubes(scene);\n    // this.generateGridHelper();\n\n    this.startClock();\n    appEl.appendChild(renderer.domElement);\n  };\n\n\n  directionalButtonPress = (e) => {\n      let isAnimating = false;\n      const direction = e.target.getAttribute(\"data-direction\") ;\n\n      if (!this.debouncedFn) {\n        this.debouncedFn = _.debounce((direction) => {\n          switch (direction) {\n            case 'ArrowLeft': // left\n              getAvailableSqByDirection(cubes, \"L\");\n              this.checkCombinationMatches();\n              isAnimating = false;\n              break;\n\n            case 'ArrowUp': // up\n              getAvailableSqByDirection(cubes, \"T\");\n              this.checkCombinationMatches();\n              isAnimating = false;\n              break;\n\n            case 'ArrowRight': // right\n              getAvailableSqByDirection(cubes, \"R\");\n              this.checkCombinationMatches();\n              isAnimating = false;\n              break;\n\n            case 'ArrowDown': // down\n              getAvailableSqByDirection(cubes, \"B\");\n              this.checkCombinationMatches();\n              isAnimating = false;\n              break;\n\n            default: return; // exit this handler\n          }\n        }, 100);\n      }\n\n      if (!isAnimating && direction) {\n        isAnimating = true;\n        this.debouncedFn(direction);\n      }\n  }\n\n  render() {\n    return (\n      <>\n\n      <div className=\"header\">\n        <span className=\"title\">Rubix</span> \n\n        <div className=\"timer\">\n          {this.parseClock(this.state.clock)}\n        </div>\n\n      <FiMenu/>\n      </div>\n\n        <div className=\"webgl\"></div>\n      </>\n    );\n  }\n}\n\nexport default Globe;"]},"metadata":{},"sourceType":"module"}