[{"/Users/drewstephenson/Documents/3DPortIntel/src/index.js":"1","/Users/drewstephenson/Documents/3DPortIntel/src/App.js":"2","/Users/drewstephenson/Documents/3DPortIntel/src/reportWebVitals.js":"3","/Users/drewstephenson/Documents/3DPortIntel/src/Globe.js":"4","/Users/drewstephenson/Documents/3DPortIntel/src/helper/intersects.js":"5","/Users/drewstephenson/Documents/3DPortIntel/src/helper/helper.js":"6","/Users/drewstephenson/Documents/3DPortIntel/src/cubes/colors.js":"7"},{"size":531,"mtime":1646671631053,"results":"8","hashOfConfig":"9"},{"size":411,"mtime":1646755019191,"results":"10","hashOfConfig":"9"},{"size":362,"mtime":1646348796418,"results":"11","hashOfConfig":"9"},{"size":16317,"mtime":1646756790898,"results":"12","hashOfConfig":"9"},{"size":5904,"mtime":1646674560450,"results":"13","hashOfConfig":"9"},{"size":860,"mtime":1646674675962,"results":"14","hashOfConfig":"9"},{"size":678,"mtime":1646674728887,"results":"15","hashOfConfig":"9"},{"filePath":"16","messages":"17","suppressedMessages":"18","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"19"},"7j9v87",{"filePath":"20","messages":"21","suppressedMessages":"22","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"23","messages":"24","suppressedMessages":"25","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"19"},{"filePath":"26","messages":"27","suppressedMessages":"28","errorCount":0,"fatalErrorCount":0,"warningCount":18,"fixableErrorCount":0,"fixableWarningCount":0,"source":"29"},{"filePath":"30","messages":"31","suppressedMessages":"32","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"33","usedDeprecatedRules":"19"},{"filePath":"34","messages":"35","suppressedMessages":"36","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"19"},{"filePath":"37","messages":"38","suppressedMessages":"39","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"19"},"/Users/drewstephenson/Documents/3DPortIntel/src/index.js",[],[],["40","41"],"/Users/drewstephenson/Documents/3DPortIntel/src/App.js",["42"],[],"/Users/drewstephenson/Documents/3DPortIntel/src/reportWebVitals.js",[],[],"/Users/drewstephenson/Documents/3DPortIntel/src/Globe.js",["43","44","45","46","47","48","49","50","51","52","53","54","55","56","57","58","59","60"],[],"import React, { Component } from \"react\";\n// import './styles/App.scss';\nimport * as THREE from \"three\";\nimport * as _ from \"lodash\";\n// import Moment from 'react-moment';\nimport moment from \"moment\";\n// import map from \"./earth-dark.jpg\";\nimport map from \"./assets/earthmap1k.jpeg\";\nimport mapClear from \"./earth_no_cloud.jpeg\";\nimport mapDark from \"./earth-dark.jpg\";\nimport bumpMap from \"./assets/earthbump.jpeg\";\nimport bumpMap2 from \"./earthbump1k.jpg\";\nimport cloudsImg from \"./assets/earthCloud.png\";\n\n// import gsap from \"gsap\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\nimport { DragControls } from \"three/examples/jsm/controls/DragControls\";\nimport vesselData from \"./vesselLegs.json\";\nimport portData from \"./ports.json\";\n\nimport lFragment from \"./utils/shader/line_fragment.glsl\";\nimport lVertex from \"./utils/shader/line_vertex.glsl\";\n\n// // import vertex from \"./shader/vertex.glsl”;\nimport {\n  BsChevronDown,\n  BsChevronLeft,\n  BsChevronRight,\n  BsChevronUp,\n} from \"react-icons/bs\";\nimport { FiMenu } from \"react-icons/fi\";\n\n// debuger\n// const gui = new dat.GUI({ closed: true });\n\nconst globeRadius = 1;\n// global\nlet camera, dragControls, scene, renderer, appEl;\nlet controls;\nlet cubes = [];\nlet globeGroup;\nlet materialShader;\nlet globe;\nlet clouds;\n// let setInervalTimer;\n\nlet masterGameMap = new Map();\nconst boardGameMap = new Map();\n\nconst game_map_row1 = new Map();\nconst game_map_row2 = new Map();\nconst game_map_row3 = new Map();\n\nconst boardGameMap_row1 = new Map();\nconst boardGameMap_row2 = new Map();\nconst boardGameMap_row3 = new Map();\n\nmasterGameMap.set(0, game_map_row1);\nmasterGameMap.set(1, game_map_row2);\nmasterGameMap.set(2, game_map_row3);\n\nboardGameMap.set(0, boardGameMap_row1);\nboardGameMap.set(1, boardGameMap_row2);\nboardGameMap.set(2, boardGameMap_row3);\n\nclass Globe extends Component {\n  constructor() {\n    super();\n    this.state = {\n      startTime: 0,\n      clock: 0,\n      masterCubeArr: [],\n    };\n  }\n\n  componentDidMount() {\n    appEl = document.getElementsByClassName(\"webgl\")[0];\n    this.init();\n    this.bindResize();\n    this.bindKeyPress();\n  }\n\n  bindKeyPress = () => {\n    window.addEventListener(\"keydown\", (e) => {\n      e.preventDefault();\n\n      let isAnimating = false;\n\n      if (!this.debouncedFn) {\n        this.debouncedFn = _.debounce((key) => {\n          switch (key) {\n            case \"ArrowLeft\": // left\n              break;\n\n            case \"ArrowUp\": // up\n              break;\n\n            case \"ArrowRight\": // right\n              break;\n\n            case \"ArrowDown\": // down\n              break;\n            default:\n              return; // exit this handler\n          }\n        }, 100);\n      }\n\n      if (!isAnimating) {\n        isAnimating = true;\n        this.debouncedFn(e.key);\n      }\n    });\n  };\n\n  bindResize = () => {\n    window.addEventListener(\"resize\", (e) => {\n      camera.aspect = window.innerWidth / window.innerHeight;\n      camera.updateProjectionMatrix();\n      renderer.setSize(window.innerWidth, window.innerHeight);\n    });\n  };\n\n  animation = (_time) => {\n    if (this.materialShader) {\n      this.materialShader.uniforms.time = _time;\n    }\n\n    clouds.rotation.y -= 0.003;\n    globeGroup.rotation.y -= 0.001;\n    //     scene.quaternion.slerp(targetQuaternion,0.01); //t = normalized value 0 to 1\n\n    cubes.forEach((o) => {\n      o.userData.update(o);\n    });\n\n    controls.update();\n    renderer.render(scene, camera);\n  };\n\n  calcPosFromLatLonRadN = (lat, lon, radius) => {\n    // var phi   = (90-lat)*(Math.PI/180);\n    // var theta = (lon)*(Math.PI/180);\n\n    // const x = -(radius * Math.sin(phi)*Math.cos(theta));\n    // const z = (radius * Math.sin(phi)*Math.sin(theta));\n    // const y = (radius * Math.cos(phi));\n\n    // return { x, y, z };\n\n    const phi = lat * (Math.PI / 180);\n    const theta = -lon * (Math.PI / 180);\n\n    var x = radius * Math.cos(phi) * Math.cos(theta);\n    var y = radius * Math.cos(phi) * Math.sin(theta);\n    var z = radius * Math.sin(phi);\n    return { x, y, z };\n  };\n\n  vertexShader = () => {\n    return `\n          varying vec3 vUv; \n      \n          void main() {\n            vUv = position; \n      \n            vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\n            gl_Position = projectionMatrix * modelViewPosition; \n          }\n        `;\n  };\n\n  //   gl_FragColor =  vec4(vUv.y, 0, 0, 1.0)\n  fragShader = () => {\n    return `\n        uniform vec3 colorA; \n        uniform vec3 colorB; \n        varying vec3 vUv;\n  \n        void main() {\n                float dash = sin(vUv.x*50)\n                if(dash<0) discard;\n        gl_FragColor = vec4(vUv.y, 0, 0, 1.0);\n        }\n    `;\n  };\n\n  init = () => {\n    globeGroup = new THREE.Group();\n    camera = new THREE.PerspectiveCamera(\n      90,\n      window.innerWidth / window.innerHeight,\n      0.000001,\n      10000\n    );\n    camera.position.z = 2;\n    //     camera.rotateX(-30)\n\n    globeGroup.rotateY(-120);\n//     globeGroup.rotateZ(-0.5);\n    scene = new THREE.Scene();\n    //     alpha: true\n\n    // scene.rotation.y += 0.180;\n    renderer = new THREE.WebGLRenderer({ antialias: true });\n    renderer.setClearColor(0x000000, 0); // the default\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    console.log(\"window.devicePixelRatio => \", window.devicePixelRatio);\n    renderer.setPixelRatio(window.devicePixelRatio); //Math.min(window.devicePixelRatio, 1));\n    renderer.setAnimationLoop(this.animation);\n\n    controls = new OrbitControls(camera, appEl);\n    controls.enableDamping = true;\n\n    let uniforms = {\n      time: { value: 0 },\n      side: THREE.DoubleSide,\n      colorB: { type: \"vec3\", value: new THREE.Color(0xacb6e5) },\n      colorA: { type: \"vec3\", value: new THREE.Color(0x74ebd5) },\n    };\n\n    materialShader = new THREE.ShaderMaterial({\n      extensions: {\n        derivatives: \"#extension GL_OES_standard_derivatives : enable\",\n      },\n      side: THREE.DoubleSide,\n      uniforms: uniforms,\n      fragmentShader: this.fragShader(),\n      vertexShader: this.vertexShader(),\n    });\n\n    // materialShader = new THREE.ShaderMaterial({\n    //   extensions: {\n    //     derivatives: \"#extension GL_OES_standard_derivatives : enable\",\n    //   },\n    //   side: THREE.DoubleSide,\n    //   uniforms: {\n    //     time: { value: 0 },\n    //     resolution: { value: new THREE.Vector4() },\n    //     colorB: {type: 'vec3', value: new THREE.Color(0xACB6E5)},\n    //     colorA: {type: 'vec3', value: new THREE.Color(0x74ebd5)}\n    //   },\n    //   wireframe: true,\n    //   transparent: true,\n    //   vertexShader: this.vertexShader(),\n    //   fragmentShader: this.fragShader(),\n    // });\n\n    // setup Map\n\n    //     const axesHelper = new THREE.AxesHelper(5);\n    //     scene.add(axesHelper);\n\n    const globeGeo = new THREE.SphereBufferGeometry(globeRadius, 32, 32);\n\n    //     uniform mat4 projectionMatrix;\n    //         uniform mat4 viewMatrix;\n    //         uniform mat4 modelMatrix;\n    // attribute vec3 position;\n    //     attribute vec2 vUv;\n    //     uniform smapler2D globeTexture;\n\n    //     precision mediump float;\n\n    //     const material = new THREE.ShaderMaterial({\n\n    //       vertexShader: `\n    //         varying vec2 vUv;\n\n    //         void main()\n    //         {\n    //                 vUv = uv;\n    //                 gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n    //         }`,\n    //       fragmentShader: `\n    //         uniform sampler2D globeTexture;\n\n    //         varying vec2 vUv;\n\n    //         void main() {\n    //             gl_FragColor = vec4(texture2D(globeTexture, vUv).xyz, .9);\n    //         }`,\n    //       uniforms: {\n    //         globalTexture: {\n    //           value: new THREE.TextureLoader().load(map),\n    //         },\n    //       },\n    //     });\n\n    //     material.uniforms.globalTexture.value = new THREE.TextureLoader().load(map);\n\n    //     uniforms: {\n    //         globalTexture: {\n    //           value: new THREE.TextureLoader().load(map),\n    //         },\n    //       },\n\n    //  vUv = uv;\n    //       uniform mat4 projectionMatrix;\n    //           uniform mat4 viewMatrix;\n    //           uniform mat4 modelMatrix;\n\n    //           attribute vec3 position;\n\n    //       precision mediump float;\n\n    //       ./earth-dark.jpg\\\\\n\n    //     import mapClear from \"./earth_no_cloud.jpeg\";\n    // import mapDark from \"./earth-dark.jpg\";\n    // import bumpMap from \"./assets/earthbump.jpeg\";\n    // import bumpMap2 from \"./earthbump1k.jpg\";\n    // import clouds from \"./earthcloudmap.jpg\";\n\n    const cloudGeometry = new THREE.SphereBufferGeometry(\n      globeRadius + 0.01,\n      32,\n      32\n    );\n    const cloudTexture = new THREE.TextureLoader().load(cloudsImg);\n\n    const mapTexture = new THREE.TextureLoader().load(mapClear);\n    //     mapTexture.anisotropy = renderer.getMaxAnisotropy();\n\n    const bumpTexture = new THREE.TextureLoader().load(bumpMap);\n    //     bumpTexture.anisotropy = renderer.getMaxAnisotropy();\n\n    const material = new THREE.MeshPhongMaterial({\n      roughness: 0.5,\n      metalness: 1,\n      map: mapTexture,\n      bumpMap: bumpTexture,\n      bumpScale: 0.08,\n      displacementMap: new THREE.TextureLoader().load(\n        \"./assets/specularmap.jpeg\"\n      ),\n    });\n\n    material.bumpMap.needsUpdate = true;\n    material.needsUpdate = true;\n\n    const cloudMaterial = new THREE.MeshPhongMaterial({\n      transparent: true,\n      map: cloudTexture,\n    });\n\n    // const globeMesh = new THREE.Mesh(globeGeo,material )\n    // map: new THREE.TextureLoader().load(map),\n    //   displacementMap: new THREE.TextureLoader().load(bumpMap),\n\n    globe = new THREE.Mesh(globeGeo, material);\n\n    clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);\n\n    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);\n    scene.add(ambientLight);\n\n    const pointLight = new THREE.PointLight(0xffffff, 0.5);\n    pointLight.position.set(5, 3, 5);\n    scene.add(pointLight);\n\n    const pointLight2 = new THREE.PointLight(0xffffff, 0.8);\n    pointLight2.position.set(-5, 3, -5);\n    scene.add(pointLight2);\n    //     const atl = [33.749, -84];\n    //     const chi = [41.8781, -87.6298];\n\n    //     const atlv = this.calcPosFromLatLonRadN(atl[0], atl[1], globeRadius);\n    //     let atlMesh = new THREE.Mesh(\n    //       new THREE.SphereBufferGeometry(0.03, 20, 20),\n    //       new THREE.MeshBasicMaterial({ color: 0xad1001 })\n    //     );\n    //     atlMesh.position.set(atlv.x, atlv.z, atlv.y);\n    //     globeGroup.add(atlMesh);\n\n    //     const chiV = this.calcPosFromLatLonRadN(chi[0], chi[1], globeRadius);\n    //     let chiMesh = new THREE.Mesh(\n    //       new THREE.SphereBufferGeometry(0.03, 20, 20),\n    //       new THREE.MeshBasicMaterial({ color: 0xf04e37 })\n    //     );\n    //     chiMesh.position.set(chiV.x, chiV.z, chiV.y);\n    //     globeGroup.add(chiMesh);\n    globeGroup.add(globe);\n    globeGroup.add(clouds);\n\n    // Atl\n    let point1 = {\n      lat: 33.749,\n      lng: -84,\n    };\n\n    // Chi\n    let point2 = {\n      lat: 41.8781,\n      lng: -87.6298,\n    };\n\n    // LA\n    let point3 = {\n      lat: 34.0522,\n      lng: -118.2437,\n    };\n\n    //\n    let point4 = {\n      lat: 35.6762,\n      lng: 139.6503,\n    };\n\n    let flights = [point1, point2, point3, point4];\n\n    console.log(\"vesselData ==> \", vesselData);\n\n    const colorArray = [\n      \"#15bece\",\n      \"#bbbd21\",\n      \"#7f7f7f\",\n      \"#e377c2\",\n      \"#8c554a\",\n      \"#9466bd\",\n      \"#d62827\",\n      \"#2da02b\",\n      \"#ff7f0f\",\n      \"#FFFFFF\",\n    ];\n    let count = 0;\n    let flightcount = 0;\n    for (const flight of flights) {\n      var color = new THREE.Color(\"#ad1001\"); // \"FFA6A6\" won't work!\n      color.getHex();\n\n      console.log('flight ==> ', flight)\n      let mesh = new THREE.Mesh(\n        new THREE.SphereBufferGeometry(0.01, 20, 20),\n        new THREE.MeshBasicMaterial({ color })\n        // this.material\n      );\n      let pos = this.calcPosFromLatLonRadN(flight.lat, flight.lng, globeRadius);\n//       mesh.position.set(pos.x, pos.z, pos.y);\n      // scene.add(mesh);\n//       scene.add(mesh);\n      if (flightcount < flights.length - 1) {\n        let pos1 = this.calcPosFromLatLonRadN(\n          flights[flightcount + 1].lat,\n          flights[flightcount + 1].lng,\n          globeRadius\n        );\n        this.getCurve(pos, pos1);\n      }\n\n      flightcount++;\n    }\n\n    for (const port of vesselData) {\n      //     const port = vesselData[i];\n      //       console.log(\"port _ \", port);\n\n      const paths = JSON.parse(port.path);\n      //       console.log(\"paths ==> \", paths);\n\n        //     if(count < 1){\n      for (const path of paths) {\n        var color = new THREE.Color(colorArray[count]); // \"FFA6A6\" won't work!\n        color.getHex(); // 0xFFA6A6\n\n        let mesh = new THREE.Mesh(\n          new THREE.SphereBufferGeometry(0.001, 20, 20),\n          new THREE.MeshBasicMaterial({ color })\n          // this.material\n        );\n        let pos = this.calcPosFromLatLonRadN(path.LAT, path.LON, globeRadius);\n        mesh.position.set(pos.x, pos.z, pos.y);\n        // scene.add(mesh);\n        globeGroup.add(mesh);\n      }\n//       }\n      //         let pos = this.calcPosFromLatLonRadN(\n      //         flight[i].lat,\n      //         flight[i].lng,\n      //         globeRadius\n      //       );\n\n      //       let mesh = new THREE.Mesh(\n      //         new THREE.SphereBufferGeometry(0.01, 20, 20),\n      //         new THREE.MeshBasicMaterial({ color: 0xff0000 })\n      //         // this.material\n      //       );\n      //       mesh.position.set(pos.x, pos.z, pos.y);\n      //       scene.add(mesh);\n\n      //       if (i < flight.length - 1) {\n      //         let pos1 = this.calcPosFromLatLonRadN(\n      //           flight[i + 1].lat,\n      //           flight[i + 1].lng,\n      //           globeRadius\n      //         );\n      //         this.getCurve(pos, pos1);\n      //       }\n      count++;\n    }\n\n    scene.add(globeGroup);\n    appEl.appendChild(renderer.domElement);\n  };\n\n  getCurve(p1, p2) {\n    let v1 = new THREE.Vector3(p1.x, p1.z, p1.y);\n    let v2 = new THREE.Vector3(p2.x, p2.z, p2.y);\n    let points = [];\n\n    for (let i = 0; i <= 10; i++) {\n      let p = new THREE.Vector3().lerpVectors(v1, v2, i / 10);\n      //       console.log(\"getCurve ==> \", p);\n      p.normalize();\n\n\n        p.multiplyScalar(1 + 0.1 * Math.sin((Math.PI * i) / 10));\n      //       p.multiplyScalar(1 + 0.41 * Math.sin((Math.PI * i) / 10));\n      // p.multiplyScalar(1 + 0.1 * Math.sin((Math.PI * i) / 10));\n      points.push(p);\n    }\n    let path = new THREE.CatmullRomCurve3(points, false);\n\n    const geometry = new THREE.TubeGeometry(path, 72, 0.005, 8, false);\n\n    let uniforms = {\n      time: { value: 0 },\n      side: THREE.DoubleSide,\n      colorB: { type: \"vec3\", value: new THREE.Color(0xacb6e5) },\n      colorA: { type: \"vec3\", value: new THREE.Color(0x74ebd5) },\n    };\n\n    //     const material = new THREE.ShaderMaterial({\n    //       extensions: {\n    //         derivatives: \"#extension GL_OES_standard_derivatives : enable\",\n    //       },\n    //       side: THREE.DoubleSide,\n    //       uniforms: uniforms,\n    //       fragmentShader: fragment,\n    //       vertexShader: this.vertexShader(),\n    //     });\n\n//     const material = new THREE.ShaderMaterial({\n//       vertexShader: `\n//         uniform mat4 projectionMatrix;\n//         uniform mat4 viewMatrix;\n//         uniform mat4 modelMatrix;\n        \n//         attribute vec3 position;\n            \n//         void main()\n//         {\n//             gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n//         }`,\n//       fragmentShader: `\n//         precision mediump float;\n//         void main() {\n//                 gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n//         }`,\n//     });\n\n    const material = new THREE.MeshBasicMaterial({ color : 0xff0000 })\n    const mesh = new THREE.Mesh(geometry, material);\n    globeGroup.add(mesh);\n  }\n\n  addVesselPaths = () => {};\n\n  removeVesselPaths = () => {};\n\n  addPorts = () => {};\n\n  addFlights = () => {};\n\n  render() {\n    return (\n      <>\n        <div className=\"webgl\"></div>\n      </>\n    );\n  }\n}\n\nexport default Globe;\n","/Users/drewstephenson/Documents/3DPortIntel/src/helper/intersects.js",["61"],[],"import * as THREE from \"three\";\nimport gsap from \"gsap\";\n\nlet cubeSize = 1;\n\nconst getIntersects = (originPoint, cubes, direction) => {\n  const intersectsResults = [];\n  const raycaster = new THREE.Raycaster();\n  const rayOrigin = new THREE.Vector3(originPoint.x, originPoint.y, 0);\n  let rayDirection;\n\n  switch (direction) {\n    case \"T\":\n      rayDirection = new THREE.Vector3(0, 2, 0).normalize();\n      break;\n\n    case \"R\":\n      rayDirection = new THREE.Vector3(2, 0, 0).normalize();\n      break;\n\n    case \"B\":\n      rayDirection = new THREE.Vector3(0, -2, 0).normalize();\n      break;\n\n    case \"L\":\n      rayDirection = new THREE.Vector3(-2, 0, 0).normalize();\n      break;\n\n    default:\n      break;\n  }\n\n  raycaster.set(rayOrigin, rayDirection);\n  const instersects = raycaster.intersectObjects(cubes)\n    .filter((mesh) => mesh.object.userData.color !== undefined);\n\n\n  if (instersects.length > 0) {\n    let distantIntersect = false;\n\n    if (instersects[0].distance > 1) {\n      distantIntersect = true\n    }\n    if (distantIntersect) {\n      intersectsResults.push(false);\n    } else {\n      intersectsResults.push(true);\n    }\n  } else {\n    intersectsResults.push(false);\n  }\n\n  return intersectsResults;\n}\n\nconst getDraggableIntersectionsOfSelectedSq = (originPoint, cubes) => {\n  const rayOrigin = new THREE.Vector3(originPoint.x, originPoint.y, 0);\n\n  const raycasterLeft = new THREE.Raycaster();\n  const raycasterTop = new THREE.Raycaster();\n  const raycasterRight = new THREE.Raycaster();\n  const raycasterBottom = new THREE.Raycaster();\n\n  const rayDirectionLeft = new THREE.Vector3(-2, 0, 0).normalize();\n  const rayDirectionTop = new THREE.Vector3(0, 2, 0).normalize();\n  const rayDirectionRight = new THREE.Vector3(2, 0, 0).normalize();\n  const rayDirectionBottom = new THREE.Vector3(0, -2, 0).normalize();\n\n  raycasterLeft.set(rayOrigin, rayDirectionLeft);\n  raycasterTop.set(rayOrigin, rayDirectionTop);\n  raycasterRight.set(rayOrigin, rayDirectionRight);\n  raycasterBottom.set(rayOrigin, rayDirectionBottom);\n\n  const instersectsLeft = raycasterLeft\n    .intersectObjects(cubes)\n    .filter((mesh) => mesh.object.userData.color !== undefined);\n  const instersectsTop = raycasterTop\n    .intersectObjects(cubes)\n    .filter((mesh) => mesh.object.userData.color !== undefined);\n  const instersectsRight = raycasterRight\n    .intersectObjects(cubes)\n    .filter((mesh) => mesh.object.userData.color !== undefined);\n  const instersectsBottom = raycasterBottom\n    .intersectObjects(cubes)\n    .filter((mesh) => mesh.object.userData.color !== undefined);\n\n  let intersectsResults = [];\n\n\n  if (instersectsTop.length > 0) {\n    const closeIntersections = instersectsTop.filter(\n      (intersect) => intersect.distance <= 0.5\n    );\n\n    if (closeIntersections.length > 0) {\n      intersectsResults.push({ T: originPoint.y });\n    } else {\n      if (instersectsTop.length > 0) {\n        intersectsResults.push({\n          T: originPoint.y + instersectsTop[0].distance - cubeSize / 2,\n        });\n      } else {\n        //\n      }\n    }\n  }\n\n  if (instersectsRight.length > 0) {\n    const closeIntersections = instersectsRight.filter(\n      (intersect) => intersect.distance <= 0.5\n    );\n    if (closeIntersections.length > 0) {\n      intersectsResults.push({ R: originPoint.x });\n    } else {\n      if (instersectsRight.length > 0) {\n        intersectsResults.push({\n          R: originPoint.x + instersectsRight[0].distance - cubeSize / 2,\n        });\n      }\n    }\n  }\n\n  if (instersectsBottom.length > 0) {\n    const closeIntersections = instersectsBottom.filter(\n      (intersect) => intersect.distance <= 0.5\n    );\n\n    if (closeIntersections.length > 0) {\n      intersectsResults.push({ B: originPoint.y });\n    } else {\n      if (instersectsBottom.length > 0) {\n        intersectsResults.push({\n          B: originPoint.y - instersectsBottom[0].distance + cubeSize / 2,\n        });\n      }\n    }\n  }\n\n  if (instersectsLeft.length > 0) {\n    const closeIntersections = instersectsLeft.filter(\n      (intersect) => intersect.distance <= 0.5\n    );\n\n    if (closeIntersections.length > 0) {\n      intersectsResults.push({ L: originPoint.x });\n    } else {\n      if (instersectsLeft.length > 0) {\n        intersectsResults.push({\n          L: originPoint.x - instersectsLeft[0].distance + cubeSize / 2,\n        });\n      }\n    }\n  }\n\n  return intersectsResults;\n}\n\nconst getAvailableSqByDirection = (cubes, direction) => {\n  cubes.filter(cube => {\n    var originPoint = cube.position.clone();\n    const intersects = getIntersects(originPoint, cubes, direction);\n    var found = false;\n    \n    for (var i = 0; i < intersects.length; i++) {\n      if (intersects[i]) {\n        found = intersects[i];\n        break;\n      } else {\n\n        const _duration = .1;\n        const _delay = 0;\n        const _easing = 'power2.out';\n\n        switch (direction) {\n          case \"T\":\n            // cube.position.y = cube.position.y + 1;\n            gsap.to(cube.position, { duration: _duration, delay: _delay, y: cube.position.y + 1, ease: _easing })\n            break;\n\n          case \"R\":\n            gsap.to(cube.position, { duration: _duration, delay: _delay, x: cube.position.x + 1, ease: _easing })\n            // cube.position.x = cube.position.x + 1;\n            break;\n\n          case \"B\":\n            // cube.position.y = cube.position.y - 1;\n            gsap.to(cube.position, { duration: _duration, delay: _delay, y: cube.position.y - 1, ease: _easing })\n            break;\n\n          case \"L\":\n            // cube.position.x = cube.position.x - 1;\n            gsap.to(cube.position, { duration: _duration, delay: _delay, x: cube.position.x - 1, ease: _easing })\n            break;\n\n          default:\n            break;\n        }\n\n      }\n    }\n\n    if (!found) {\n      return cube;\n    }\n  });\n}\n\nexport { getDraggableIntersectionsOfSelectedSq, getAvailableSqByDirection };","/Users/drewstephenson/Documents/3DPortIntel/src/helper/helper.js",[],[],"/Users/drewstephenson/Documents/3DPortIntel/src/cubes/colors.js",[],[],{"ruleId":"62","replacedBy":"63"},{"ruleId":"64","replacedBy":"65"},{"ruleId":"66","severity":1,"message":"67","line":1,"column":8,"nodeType":"68","messageId":"69","endLine":1,"endColumn":12},{"ruleId":"66","severity":1,"message":"70","line":6,"column":8,"nodeType":"68","messageId":"69","endLine":6,"endColumn":14},{"ruleId":"66","severity":1,"message":"71","line":8,"column":8,"nodeType":"68","messageId":"69","endLine":8,"endColumn":11},{"ruleId":"66","severity":1,"message":"72","line":10,"column":8,"nodeType":"68","messageId":"69","endLine":10,"endColumn":15},{"ruleId":"66","severity":1,"message":"73","line":12,"column":8,"nodeType":"68","messageId":"69","endLine":12,"endColumn":16},{"ruleId":"66","severity":1,"message":"74","line":17,"column":10,"nodeType":"68","messageId":"69","endLine":17,"endColumn":22},{"ruleId":"66","severity":1,"message":"75","line":19,"column":8,"nodeType":"68","messageId":"69","endLine":19,"endColumn":16},{"ruleId":"66","severity":1,"message":"76","line":21,"column":8,"nodeType":"68","messageId":"69","endLine":21,"endColumn":17},{"ruleId":"66","severity":1,"message":"77","line":22,"column":8,"nodeType":"68","messageId":"69","endLine":22,"endColumn":15},{"ruleId":"66","severity":1,"message":"78","line":26,"column":3,"nodeType":"68","messageId":"69","endLine":26,"endColumn":16},{"ruleId":"66","severity":1,"message":"79","line":27,"column":3,"nodeType":"68","messageId":"69","endLine":27,"endColumn":16},{"ruleId":"66","severity":1,"message":"80","line":28,"column":3,"nodeType":"68","messageId":"69","endLine":28,"endColumn":17},{"ruleId":"66","severity":1,"message":"81","line":29,"column":3,"nodeType":"68","messageId":"69","endLine":29,"endColumn":14},{"ruleId":"66","severity":1,"message":"82","line":31,"column":10,"nodeType":"68","messageId":"69","endLine":31,"endColumn":16},{"ruleId":"66","severity":1,"message":"83","line":38,"column":13,"nodeType":"68","messageId":"69","endLine":38,"endColumn":25},{"ruleId":"66","severity":1,"message":"84","line":42,"column":5,"nodeType":"68","messageId":"69","endLine":42,"endColumn":19},{"ruleId":"66","severity":1,"message":"85","line":433,"column":11,"nodeType":"68","messageId":"69","endLine":433,"endColumn":15},{"ruleId":"86","severity":1,"message":"87","line":463,"column":13,"nodeType":"68","messageId":"88","endLine":463,"endColumn":18},{"ruleId":"66","severity":1,"message":"89","line":526,"column":9,"nodeType":"68","messageId":"69","endLine":526,"endColumn":17},{"ruleId":"90","severity":1,"message":"91","line":159,"column":21,"nodeType":"92","messageId":"93","endLine":159,"endColumn":23},"no-native-reassign",["94"],"no-negated-in-lhs",["95"],"no-unused-vars","'logo' is defined but never used.","Identifier","unusedVar","'moment' is defined but never used.","'map' is defined but never used.","'mapDark' is defined but never used.","'bumpMap2' is defined but never used.","'DragControls' is defined but never used.","'portData' is defined but never used.","'lFragment' is defined but never used.","'lVertex' is defined but never used.","'BsChevronDown' is defined but never used.","'BsChevronLeft' is defined but never used.","'BsChevronRight' is defined but never used.","'BsChevronUp' is defined but never used.","'FiMenu' is defined but never used.","'dragControls' is defined but never used.","'materialShader' is assigned a value but never used.","'mesh' is assigned a value but never used.","no-redeclare","'color' is already defined.","redeclared","'uniforms' is assigned a value but never used.","array-callback-return","Array.prototype.filter() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd","no-global-assign","no-unsafe-negation"]