[{"/Users/drewstephenson/Documents/3DPortIntel/src/index.js":"1","/Users/drewstephenson/Documents/3DPortIntel/src/App.js":"2","/Users/drewstephenson/Documents/3DPortIntel/src/reportWebVitals.js":"3","/Users/drewstephenson/Documents/3DPortIntel/src/Globe.js":"4","/Users/drewstephenson/Documents/3DPortIntel/src/helper/intersects.js":"5","/Users/drewstephenson/Documents/3DPortIntel/src/helper/helper.js":"6","/Users/drewstephenson/Documents/3DPortIntel/src/cubes/colors.js":"7"},{"size":531,"mtime":1646671631053,"results":"8","hashOfConfig":"9"},{"size":411,"mtime":1646677134489,"results":"10","hashOfConfig":"9"},{"size":362,"mtime":1646348796418,"results":"11","hashOfConfig":"9"},{"size":10316,"mtime":1646711638794,"results":"12","hashOfConfig":"9"},{"size":5904,"mtime":1646674560450,"results":"13","hashOfConfig":"9"},{"size":860,"mtime":1646674675962,"results":"14","hashOfConfig":"9"},{"size":678,"mtime":1646674728887,"results":"15","hashOfConfig":"9"},{"filePath":"16","messages":"17","suppressedMessages":"18","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"19"},"7j9v87",{"filePath":"20","messages":"21","suppressedMessages":"22","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"23","usedDeprecatedRules":"19"},{"filePath":"24","messages":"25","suppressedMessages":"26","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"19"},{"filePath":"27","messages":"28","suppressedMessages":"29","errorCount":0,"fatalErrorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":"30"},{"filePath":"31","messages":"32","suppressedMessages":"33","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"34","usedDeprecatedRules":"19"},{"filePath":"35","messages":"36","suppressedMessages":"37","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"19"},{"filePath":"38","messages":"39","suppressedMessages":"40","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"19"},"/Users/drewstephenson/Documents/3DPortIntel/src/index.js",[],[],["41","42"],"/Users/drewstephenson/Documents/3DPortIntel/src/App.js",["43"],[],"import logo from './logo.svg';\nimport './App.css';\nimport { Typography } from '@material-ui/core';\nimport Globe from './Globe';\nimport { FiMenu } from 'react-icons/fi';\n\nfunction App() {\n\n\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <Typography variant=\"h4\">Port Intel </Typography>\n        <FiMenu/>\n      </header>\n      <Globe/>\n    </div>\n  );\n}\n\nexport default App;\n","/Users/drewstephenson/Documents/3DPortIntel/src/reportWebVitals.js",[],[],"/Users/drewstephenson/Documents/3DPortIntel/src/Globe.js",["44","45","46","47","48","49","50","51","52","53","54","55","56","57","58","59"],[],"import React, { Component } from \"react\";\n// import './styles/App.scss';\nimport * as THREE from \"three\";\nimport * as _ from \"lodash\";\n// import Moment from 'react-moment';\nimport moment from \"moment\";\n// import map from \"./earth-dark.jpg\";\nimport map from \"./earthmap1k.jpg\";\n\n// import gsap from \"gsap\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\nimport { DragControls } from \"three/examples/jsm/controls/DragControls\";\nimport { shuffle, isWinningCombination } from \"./helper/helper\";\nimport { rubik_colors, color_opt_array } from \"./cubes/colors\";\nimport {\n  getDraggableIntersectionsOfSelectedSq,\n  getAvailableSqByDirection,\n} from \"./helper/intersects\";\n// import { generateGameboardCubes, generateMasterCubes } from './cubes/gameboard';\n// import { generateMasterCubeDisplay } from './controls/controls';\n\nimport lFragment from \"./utils/shader/line_fragment.glsl\";\nimport lVertex from \"./utils/shader/line_vertex.glsl\";\n\n// // import vertex from \"./shader/vertex.glsl”;\nimport {\n  BsChevronDown,\n  BsChevronLeft,\n  BsChevronRight,\n  BsChevronUp,\n} from \"react-icons/bs\";\nimport { FiMenu } from \"react-icons/fi\";\n\n// debuger\n// const gui = new dat.GUI({ closed: true });\n\nconst globeRadius = 3;\n// global\nlet camera, dragControls, scene, renderer, appEl;\nlet controls;\nlet cubes = [];\nlet globeGroup;\nlet materialShader;\n// let setInervalTimer;\n\nlet masterGameMap = new Map();\nconst boardGameMap = new Map();\n\nconst game_map_row1 = new Map();\nconst game_map_row2 = new Map();\nconst game_map_row3 = new Map();\n\nconst boardGameMap_row1 = new Map();\nconst boardGameMap_row2 = new Map();\nconst boardGameMap_row3 = new Map();\n\nmasterGameMap.set(0, game_map_row1);\nmasterGameMap.set(1, game_map_row2);\nmasterGameMap.set(2, game_map_row3);\n\nboardGameMap.set(0, boardGameMap_row1);\nboardGameMap.set(1, boardGameMap_row2);\nboardGameMap.set(2, boardGameMap_row3);\n\nclass Globe extends Component {\n  constructor() {\n    super();\n    this.state = {\n      startTime: 0,\n      clock: 0,\n      masterCubeArr: [],\n    };\n  }\n\n  componentDidMount() {\n    appEl = document.getElementsByClassName(\"webgl\")[0];\n    this.init();\n    this.bindResize();\n    this.bindKeyPress();\n  }\n\n  bindKeyPress = () => {\n    window.addEventListener(\"keydown\", (e) => {\n      e.preventDefault();\n\n      let isAnimating = false;\n\n      if (!this.debouncedFn) {\n        this.debouncedFn = _.debounce((key) => {\n          switch (key) {\n            case \"ArrowLeft\": // left\n              break;\n\n            case \"ArrowUp\": // up\n              break;\n\n            case \"ArrowRight\": // right\n              break;\n\n            case \"ArrowDown\": // down\n              break;\n            default:\n              return; // exit this handler\n          }\n        }, 100);\n      }\n\n      if (!isAnimating) {\n        isAnimating = true;\n        this.debouncedFn(e.key);\n      }\n    });\n  };\n\n  bindResize = () => {\n    window.addEventListener(\"resize\", (e) => {\n      camera.aspect = window.innerWidth / window.innerHeight;\n      camera.updateProjectionMatrix();\n      renderer.setSize(window.innerWidth, window.innerHeight);\n    });\n  };\n\n  generateGridHelper = () => {\n    var standardPlaneNormal = new THREE.Vector3(0, 0, 1);\n    var GridHelperPlaneNormal = new THREE.Vector3(0, 1, 0);\n    var GridHelperPlaneMaster = new THREE.Vector3(0, 1, 0);\n\n    var quaternion = new THREE.Quaternion();\n    quaternion.setFromUnitVectors(standardPlaneNormal, GridHelperPlaneNormal);\n\n    var masterQuaternion = new THREE.Quaternion();\n    masterQuaternion.setFromUnitVectors(\n      standardPlaneNormal,\n      GridHelperPlaneMaster\n    );\n\n    var largeGridGuide = new THREE.GridHelper(10, 10);\n    largeGridGuide.rotation.setFromQuaternion(quaternion);\n\n    scene.add(largeGridGuide);\n  };\n\n  animation = (_time) => {\n    if (this.materialShader) {\n      this.materialShader.uniforms.time = _time;\n    }\n\n    cubes.forEach((o) => {\n      o.userData.update(o);\n    });\n\n    controls.update();\n    renderer.render(scene, camera);\n  };\n\n  calcPosFromLatLonRadN = (lat, lon, radius) => {\n    const phi = lat * (Math.PI / 180);\n    const theta = -lon * (Math.PI / 180);\n\n    var x = radius * Math.cos(phi) * Math.cos(theta);\n    var y = radius * Math.cos(phi) * Math.sin(theta);\n    var z = radius * Math.sin(phi);\n    return { x, y, z };\n  };\n\n  vertexShader = () => {\n    return `\n          varying vec3 vUv; \n      \n          void main() {\n            vUv = position; \n      \n            vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\n            gl_Position = projectionMatrix * modelViewPosition; \n          }\n        `;\n  };\n\n  //   gl_FragColor =  vec4(vUv.y, 0, 0, 1.0)\n  fragShader = () => {\n    return `\n        uniform vec3 colorA; \n        uniform vec3 colorB; \n        varying vec3 vUv;\n  \n        void main() {\n                float dash = sin(vUv.x*50)\n                if(dash<0) discard;\n        gl_FragColor = vec4(vUv.y, 0, 0, 1.0);\n        }\n    `;\n  };\n\n  init = () => {\n    globeGroup = new THREE.Group();\n    camera = new THREE.PerspectiveCamera(\n      90,\n      window.innerWidth / window.innerHeight,\n      0.01,\n      100\n    );\n    camera.position.z = 6;\n    scene = new THREE.Scene();\n\n    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\n    renderer.setClearColor(0x000000, 0); // the default\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1));\n    renderer.setAnimationLoop(this.animation);\n\n    controls = new OrbitControls(camera, appEl);\n    controls.enableDamping = true;\n\n    let uniforms = {\n      time: { value: 0 },\n      side: THREE.DoubleSide,\n      colorB: { type: \"vec3\", value: new THREE.Color(0xacb6e5) },\n      colorA: { type: \"vec3\", value: new THREE.Color(0x74ebd5) },\n    };\n\n    materialShader = new THREE.ShaderMaterial({\n      extensions: {\n        derivatives: \"#extension GL_OES_standard_derivatives : enable\",\n      },\n      side: THREE.DoubleSide,\n      uniforms: uniforms,\n      fragmentShader: this.fragShader(),\n      vertexShader: this.vertexShader(),\n    });\n\n    // materialShader = new THREE.ShaderMaterial({\n    //   extensions: {\n    //     derivatives: \"#extension GL_OES_standard_derivatives : enable\",\n    //   },\n    //   side: THREE.DoubleSide,\n    //   uniforms: {\n    //     time: { value: 0 },\n    //     resolution: { value: new THREE.Vector4() },\n    //     colorB: {type: 'vec3', value: new THREE.Color(0xACB6E5)},\n    //     colorA: {type: 'vec3', value: new THREE.Color(0x74ebd5)}\n    //   },\n    //   wireframe: true,\n    //   transparent: true,\n    //   vertexShader: this.vertexShader(),\n    //   fragmentShader: this.fragShader(),\n    // });\n\n    // setup Map\n\n    const axesHelper = new THREE.AxesHelper(5);\n    scene.add(axesHelper);\n\n    const globeGeo = new THREE.SphereBufferGeometry(globeRadius);\n    const material = new THREE.MeshBasicMaterial({\n      map: new THREE.TextureLoader().load(map),\n    });\n\n    const globe = new THREE.Mesh(globeGeo, material);\n\n    //     const atl = [33.749, -84];\n    //     const chi = [41.8781, -87.6298];\n\n    //     const atlv = this.calcPosFromLatLonRadN(atl[0], atl[1], globeRadius);\n    //     let atlMesh = new THREE.Mesh(\n    //       new THREE.SphereBufferGeometry(0.03, 20, 20),\n    //       new THREE.MeshBasicMaterial({ color: 0xad1001 })\n    //     );\n    //     atlMesh.position.set(atlv.x, atlv.z, atlv.y);\n    //     globeGroup.add(atlMesh);\n\n    //     const chiV = this.calcPosFromLatLonRadN(chi[0], chi[1], globeRadius);\n    //     let chiMesh = new THREE.Mesh(\n    //       new THREE.SphereBufferGeometry(0.03, 20, 20),\n    //       new THREE.MeshBasicMaterial({ color: 0xf04e37 })\n    //     );\n    //     chiMesh.position.set(chiV.x, chiV.z, chiV.y);\n    //     globeGroup.add(chiMesh);\n    globeGroup.add(globe);\n\n    // Atl\n    let point1 = {\n      lat: 33.749,\n      lng: -84,\n    };\n\n    // Chi\n    let point2 = {\n      lat: 41.8781,\n      lng: -87.6298,\n    };\n\n    // LA\n    let point3 = {\n      lat: 34.0522,\n      lng: -118.2437,\n    };\n\n    //\n    let point4 = {\n      lat: 35.6762,\n      lng: 139.6503,\n    };\n\n    let flight = [point1, point2, point3, point4];\n\n    for (var i = 0; i < flight.length; i++) {\n      let pos = this.calcPosFromLatLonRadN(\n        flight[i].lat,\n        flight[i].lng,\n        globeRadius\n      );\n\n      let mesh = new THREE.Mesh(\n        new THREE.SphereBufferGeometry(0.03, 20, 20),\n        new THREE.MeshBasicMaterial({ color: 0xff0000 })\n        // this.material\n      );\n      mesh.position.set(pos.x, pos.z, pos.y);\n      scene.add(mesh);\n\n      if (i < flight.length - 1) {\n        let pos1 = this.calcPosFromLatLonRadN(\n          flight[i + 1].lat,\n          flight[i + 1].lng,\n          globeRadius\n        );\n        this.getCurve(pos, pos1);\n      }\n    }\n    scene.add(globeGroup);\n    appEl.appendChild(renderer.domElement);\n  };\n\n  getCurve(p1, p2) {\n    let v1 = new THREE.Vector3(p1.x, p1.z, p1.y);\n    let v2 = new THREE.Vector3(p2.x, p2.z, p2.y);\n    let points = [];\n\n    for (let i = 0; i <= 20; i++) {\n      let p = new THREE.Vector3().lerpVectors(v1, v2, i / 20);\n      //       console.log(\"getCurve ==> \", p);\n//       p.normalize()\n      p.multiplyScalar(1 + 0.51 * Math.sin((Math.PI * i) / 20));\n      points.push(p);\n    }\n    let path = new THREE.CatmullRomCurve3(points, false);\n\n    const geometry = new THREE.TubeGeometry(path, 72, 0.005, 8, false);\n\n    let uniforms = {\n      time: { value: 0 },\n      side: THREE.DoubleSide,\n      colorB: { type: \"vec3\", value: new THREE.Color(0xacb6e5) },\n      colorA: { type: \"vec3\", value: new THREE.Color(0x74ebd5) },\n    };\n\n//     const material = new THREE.ShaderMaterial({\n//       extensions: {\n//         derivatives: \"#extension GL_OES_standard_derivatives : enable\",\n//       },\n//       side: THREE.DoubleSide,\n//       uniforms: uniforms,\n//       fragmentShader: fragment,\n//       vertexShader: this.vertexShader(),\n//     });\n\n    const material = new THREE.RawShaderMaterial({\n        vertexShader:lVertex,\n        fragmentShader: lFragment\n    })\n\n    const mesh = new THREE.Mesh(geometry, material);\n    globeGroup.add(mesh);\n  }\n\n  render() {\n    return (\n      <>\n        <div className=\"webgl\"></div>\n      </>\n    );\n  }\n}\n\nexport default Globe;\n","/Users/drewstephenson/Documents/3DPortIntel/src/helper/intersects.js",["60"],[],"import * as THREE from \"three\";\nimport gsap from \"gsap\";\n\nlet cubeSize = 1;\n\nconst getIntersects = (originPoint, cubes, direction) => {\n  const intersectsResults = [];\n  const raycaster = new THREE.Raycaster();\n  const rayOrigin = new THREE.Vector3(originPoint.x, originPoint.y, 0);\n  let rayDirection;\n\n  switch (direction) {\n    case \"T\":\n      rayDirection = new THREE.Vector3(0, 2, 0).normalize();\n      break;\n\n    case \"R\":\n      rayDirection = new THREE.Vector3(2, 0, 0).normalize();\n      break;\n\n    case \"B\":\n      rayDirection = new THREE.Vector3(0, -2, 0).normalize();\n      break;\n\n    case \"L\":\n      rayDirection = new THREE.Vector3(-2, 0, 0).normalize();\n      break;\n\n    default:\n      break;\n  }\n\n  raycaster.set(rayOrigin, rayDirection);\n  const instersects = raycaster.intersectObjects(cubes)\n    .filter((mesh) => mesh.object.userData.color !== undefined);\n\n\n  if (instersects.length > 0) {\n    let distantIntersect = false;\n\n    if (instersects[0].distance > 1) {\n      distantIntersect = true\n    }\n    if (distantIntersect) {\n      intersectsResults.push(false);\n    } else {\n      intersectsResults.push(true);\n    }\n  } else {\n    intersectsResults.push(false);\n  }\n\n  return intersectsResults;\n}\n\nconst getDraggableIntersectionsOfSelectedSq = (originPoint, cubes) => {\n  const rayOrigin = new THREE.Vector3(originPoint.x, originPoint.y, 0);\n\n  const raycasterLeft = new THREE.Raycaster();\n  const raycasterTop = new THREE.Raycaster();\n  const raycasterRight = new THREE.Raycaster();\n  const raycasterBottom = new THREE.Raycaster();\n\n  const rayDirectionLeft = new THREE.Vector3(-2, 0, 0).normalize();\n  const rayDirectionTop = new THREE.Vector3(0, 2, 0).normalize();\n  const rayDirectionRight = new THREE.Vector3(2, 0, 0).normalize();\n  const rayDirectionBottom = new THREE.Vector3(0, -2, 0).normalize();\n\n  raycasterLeft.set(rayOrigin, rayDirectionLeft);\n  raycasterTop.set(rayOrigin, rayDirectionTop);\n  raycasterRight.set(rayOrigin, rayDirectionRight);\n  raycasterBottom.set(rayOrigin, rayDirectionBottom);\n\n  const instersectsLeft = raycasterLeft\n    .intersectObjects(cubes)\n    .filter((mesh) => mesh.object.userData.color !== undefined);\n  const instersectsTop = raycasterTop\n    .intersectObjects(cubes)\n    .filter((mesh) => mesh.object.userData.color !== undefined);\n  const instersectsRight = raycasterRight\n    .intersectObjects(cubes)\n    .filter((mesh) => mesh.object.userData.color !== undefined);\n  const instersectsBottom = raycasterBottom\n    .intersectObjects(cubes)\n    .filter((mesh) => mesh.object.userData.color !== undefined);\n\n  let intersectsResults = [];\n\n\n  if (instersectsTop.length > 0) {\n    const closeIntersections = instersectsTop.filter(\n      (intersect) => intersect.distance <= 0.5\n    );\n\n    if (closeIntersections.length > 0) {\n      intersectsResults.push({ T: originPoint.y });\n    } else {\n      if (instersectsTop.length > 0) {\n        intersectsResults.push({\n          T: originPoint.y + instersectsTop[0].distance - cubeSize / 2,\n        });\n      } else {\n        //\n      }\n    }\n  }\n\n  if (instersectsRight.length > 0) {\n    const closeIntersections = instersectsRight.filter(\n      (intersect) => intersect.distance <= 0.5\n    );\n    if (closeIntersections.length > 0) {\n      intersectsResults.push({ R: originPoint.x });\n    } else {\n      if (instersectsRight.length > 0) {\n        intersectsResults.push({\n          R: originPoint.x + instersectsRight[0].distance - cubeSize / 2,\n        });\n      }\n    }\n  }\n\n  if (instersectsBottom.length > 0) {\n    const closeIntersections = instersectsBottom.filter(\n      (intersect) => intersect.distance <= 0.5\n    );\n\n    if (closeIntersections.length > 0) {\n      intersectsResults.push({ B: originPoint.y });\n    } else {\n      if (instersectsBottom.length > 0) {\n        intersectsResults.push({\n          B: originPoint.y - instersectsBottom[0].distance + cubeSize / 2,\n        });\n      }\n    }\n  }\n\n  if (instersectsLeft.length > 0) {\n    const closeIntersections = instersectsLeft.filter(\n      (intersect) => intersect.distance <= 0.5\n    );\n\n    if (closeIntersections.length > 0) {\n      intersectsResults.push({ L: originPoint.x });\n    } else {\n      if (instersectsLeft.length > 0) {\n        intersectsResults.push({\n          L: originPoint.x - instersectsLeft[0].distance + cubeSize / 2,\n        });\n      }\n    }\n  }\n\n  return intersectsResults;\n}\n\nconst getAvailableSqByDirection = (cubes, direction) => {\n  cubes.filter(cube => {\n    var originPoint = cube.position.clone();\n    const intersects = getIntersects(originPoint, cubes, direction);\n    var found = false;\n    \n    for (var i = 0; i < intersects.length; i++) {\n      if (intersects[i]) {\n        found = intersects[i];\n        break;\n      } else {\n\n        const _duration = .1;\n        const _delay = 0;\n        const _easing = 'power2.out';\n\n        switch (direction) {\n          case \"T\":\n            // cube.position.y = cube.position.y + 1;\n            gsap.to(cube.position, { duration: _duration, delay: _delay, y: cube.position.y + 1, ease: _easing })\n            break;\n\n          case \"R\":\n            gsap.to(cube.position, { duration: _duration, delay: _delay, x: cube.position.x + 1, ease: _easing })\n            // cube.position.x = cube.position.x + 1;\n            break;\n\n          case \"B\":\n            // cube.position.y = cube.position.y - 1;\n            gsap.to(cube.position, { duration: _duration, delay: _delay, y: cube.position.y - 1, ease: _easing })\n            break;\n\n          case \"L\":\n            // cube.position.x = cube.position.x - 1;\n            gsap.to(cube.position, { duration: _duration, delay: _delay, x: cube.position.x - 1, ease: _easing })\n            break;\n\n          default:\n            break;\n        }\n\n      }\n    }\n\n    if (!found) {\n      return cube;\n    }\n  });\n}\n\nexport { getDraggableIntersectionsOfSelectedSq, getAvailableSqByDirection };","/Users/drewstephenson/Documents/3DPortIntel/src/helper/helper.js",[],[],"/Users/drewstephenson/Documents/3DPortIntel/src/cubes/colors.js",[],[],{"ruleId":"61","replacedBy":"62"},{"ruleId":"63","replacedBy":"64"},{"ruleId":"65","severity":1,"message":"66","line":1,"column":8,"nodeType":"67","messageId":"68","endLine":1,"endColumn":12},{"ruleId":"65","severity":1,"message":"69","line":6,"column":8,"nodeType":"67","messageId":"68","endLine":6,"endColumn":14},{"ruleId":"65","severity":1,"message":"70","line":12,"column":10,"nodeType":"67","messageId":"68","endLine":12,"endColumn":22},{"ruleId":"65","severity":1,"message":"71","line":13,"column":10,"nodeType":"67","messageId":"68","endLine":13,"endColumn":17},{"ruleId":"65","severity":1,"message":"72","line":13,"column":19,"nodeType":"67","messageId":"68","endLine":13,"endColumn":39},{"ruleId":"65","severity":1,"message":"73","line":14,"column":10,"nodeType":"67","messageId":"68","endLine":14,"endColumn":22},{"ruleId":"65","severity":1,"message":"74","line":14,"column":24,"nodeType":"67","messageId":"68","endLine":14,"endColumn":39},{"ruleId":"65","severity":1,"message":"75","line":16,"column":3,"nodeType":"67","messageId":"68","endLine":16,"endColumn":40},{"ruleId":"65","severity":1,"message":"76","line":17,"column":3,"nodeType":"67","messageId":"68","endLine":17,"endColumn":28},{"ruleId":"65","severity":1,"message":"77","line":27,"column":3,"nodeType":"67","messageId":"68","endLine":27,"endColumn":16},{"ruleId":"65","severity":1,"message":"78","line":28,"column":3,"nodeType":"67","messageId":"68","endLine":28,"endColumn":16},{"ruleId":"65","severity":1,"message":"79","line":29,"column":3,"nodeType":"67","messageId":"68","endLine":29,"endColumn":17},{"ruleId":"65","severity":1,"message":"80","line":30,"column":3,"nodeType":"67","messageId":"68","endLine":30,"endColumn":14},{"ruleId":"65","severity":1,"message":"81","line":32,"column":10,"nodeType":"67","messageId":"68","endLine":32,"endColumn":16},{"ruleId":"65","severity":1,"message":"82","line":39,"column":13,"nodeType":"67","messageId":"68","endLine":39,"endColumn":25},{"ruleId":"65","severity":1,"message":"83","line":43,"column":5,"nodeType":"67","messageId":"68","endLine":43,"endColumn":19},{"ruleId":"65","severity":1,"message":"84","line":350,"column":9,"nodeType":"67","messageId":"68","endLine":350,"endColumn":17},{"ruleId":"85","severity":1,"message":"86","line":159,"column":21,"nodeType":"87","messageId":"88","endLine":159,"endColumn":23},"no-native-reassign",["89"],"no-negated-in-lhs",["90"],"no-unused-vars","'logo' is defined but never used.","Identifier","unusedVar","'moment' is defined but never used.","'DragControls' is defined but never used.","'shuffle' is defined but never used.","'isWinningCombination' is defined but never used.","'rubik_colors' is defined but never used.","'color_opt_array' is defined but never used.","'getDraggableIntersectionsOfSelectedSq' is defined but never used.","'getAvailableSqByDirection' is defined but never used.","'BsChevronDown' is defined but never used.","'BsChevronLeft' is defined but never used.","'BsChevronRight' is defined but never used.","'BsChevronUp' is defined but never used.","'FiMenu' is defined but never used.","'dragControls' is defined but never used.","'materialShader' is assigned a value but never used.","'uniforms' is assigned a value but never used.","array-callback-return","Array.prototype.filter() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd","no-global-assign","no-unsafe-negation"]